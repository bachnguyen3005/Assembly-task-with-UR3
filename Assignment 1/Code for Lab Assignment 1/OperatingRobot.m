classdef OperatingRobot < handle

    properties
   
        
    end

    methods (Static) 
        
        %Fucntion to generate the set of q to create the trajectory from
        %jtraj
        function qtrajec = CreateTraj(robot,brickPosition,jointGuess)

            steps = 100;

            qNow = robot.model.getpos();

            T = transl(brickPosition)*trotx(pi)*troty(0)*trotz(0);
                
            %Joint states that pick up the brick
            qMove = wrapToPi(robot.model.ikcon(T,jointGuess));

            qtrajec = jtraj(qNow,qMove,steps);

        end
        

        %Function to move the arm from random position to pick up the brick
        function  MoveToBrick(r,qtrajec,finger1,finger2)

            for i = 1:size(qtrajec,1)
                q = qtrajec(i,:);
                r.model.animate(q);
                MoveFinger(r,q,finger1,finger2,i);
                pause(0.01)
            end

        end

        %Function to move the base of the gripper with the end-effector
        function MoveFinger(r,q,finger1,finger2,i)

            q_f1 = finger1.model.getpos();
            q_f2 = finger2.model.getpos();
            q_f1_end = deg2rad([25 0]);
            q_f2_end = deg2rad([25 0]);
            q_f1_traj = jtraj(q_f1,q_f1_end,100);
            q_f2_traj = jtraj(q_f2,q_f2_end,100);
            base = r.model.fkineUTS(q);
            
            %Update the base of the gripper and also move the finger
            %simutaneously
            finger1.model.base=base*trotx(pi/2);

            finger1.model.animate(q_f1_traj(i,:));

            finger2.model.base=base*troty(pi)*trotx(-pi/2);

            finger2.model.animate(q_f2_traj(i,:));

        end

        % This function has 5 input:
        % self is the robot arm
        % qArray is the set of q generated by the inverse kinematic from the start and end position
        % f1 is the finger 1, a 2d planar robot
        % f2 is the finger 2
        % bricknum is the x,y,z coordinate of the brick
        function PlotPose(self,qArray,freq,f1,f2,bricknum)



            figure(1);

            %Create a log file for debug
            logFileName = strcat('logLinearUR3',self.model.name,'.log');
            L = log4matlab(logFileName);
            disp(strcat("Logging on file: ",logFileName));

            num = 1;
            %Read the ply file in faces, vertices, and color it
            [f,v,data] = plyread('OrangeBrick.ply','tri');
            vertexColours = [data.vertex.red, data.vertex.green, data.vertex.blue] / 255;
            BrickVertexCount = size(v,1);
            BrickMesh_h = trisurf(f,v(:,1)+bricknum(1,1),v(:,2)+bricknum(1,2), v(:,3)+bricknum(1,3) ...
                ,'FaceVertexCData',vertexColours,'EdgeColor','none','EdgeLighting','none');


            for i=1:size(qArray,1)

                % Take the forward kinematic for the brick
                brick = self.model.fkineUTS(qArray(i,:));

                %Create a BrickPose after it run through a row of qArray, BrickPose is the
                %4x4 matrix, transl(0,0,0.1) is move the brick down 0.1 in the Z direction
                %to make it look like it is graspped by the gripper
                BrickPose = brick*transl(0,0,0.1) ;

                %MOVE THE BRICK. Update the point then multiply it to the vertices
                UpdatedPoints = [BrickPose * [v,ones(BrickVertexCount,1)]']';

                %The vertices are all the rows and 1 to 3 columns of the UpdatedPoints
                BrickMesh_h.Vertices = UpdatedPoints(:,1:3);

                %Animate the robot arm
                self.model.animate(qArray(i,:));

                %Create a set of joint states to make the finger open from 0 degree to 20

                q_f1 = f1.model.getpos();
                q_f2 = f2.model.getpos();
                q_f1_end = deg2rad([10 0]);
                q_f2_end = deg2rad([10 0]);
                q_f1_traj = jtraj(q_f1,q_f1_end,100);
                q_f2_traj = jtraj(q_f2,q_f2_end,100);


                %Transform the gripper by update the base and OPEN THE FINGER SIMUTANEOUSLY
                base = self.model.fkineUTS(qArray(i,:));
                f1.model.base = base*trotx(pi/2);
                f1.model.animate(q_f1_traj(i,:))
                f2.model.base = base*troty(pi)*trotx(-pi/2);
                f2.model.animate(q_f2_traj(i,:))

                pause(0.0005);

                %Display the current position of the end-effector every 'freq' times
                if mod(num,freq) == 0
                    currPosition = transl(self.model.fkine(qArray(i,:)).T)';
                    message = strcat('DEBUG: ',' Current position = ',num2str(currPosition));
                    L.mlog = {L.DEBUG,'LinearUR3',message};
                    disp(message);
                end
                num = num + 1;

            end

        end
        
        %Function to plot and calculate the volume
        function [h_] = PlotVolume(self, createNew, color)

            %base = transl(self.model.base);
            stepRads = deg2rad(60);
            stepmeter = 0.2;
            qlim =[-0.8 -0.01 ; -2*pi 2*pi; -90*pi/180 90*pi/180; -170*pi/180 170*pi/180;-2*pi 2*pi;-2*pi 2*pi;-2*pi 2*pi];

            %qlim = self.qlim;
            if createNew == 1 % only if pointCloud has not been create yet
                %pointCloudeSize = prod(floor((qlim(2:6,2)-qlim(2:6,1))/stepRads + 1));
                a = [4 13 4 6 13 13];
                pointCloudeSize = prod(a);
                pointCloud = zeros(pointCloudeSize,3);
                disp(num2str(size(pointCloud)));
                counter = 1;
                tic
                for q1 = qlim(1,1):stepmeter:qlim(1,2)
                    for q2 = qlim(2,1):stepRads:qlim(2,2)
                        for q3 = qlim(3,1):stepRads:qlim(3,2)
                            for q4 = qlim(4,1):stepRads:qlim(4,2)
                                for q5 = qlim(5,1):stepRads:qlim(5,2)
                                    for q6 = qlim(6,1):stepRads:qlim(6,2)
                                        q7 = 0;
                                        q = [q1,q2,q3,q4,q5,q6,q7];
                                        tr = self.model.fkineUTS(q);
                                        pointCloud(counter,:) = tr(1:3,4)';
                                        counter = counter + 1;

                                        if mod(counter/pointCloudeSize * 100,1) == 0
                                            display(['After ',num2str(toc),' seconds, completed ',num2str(counter/pointCloudeSize * 100),'% of poses']);
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end

            hold on;
            if color == "red"
                color = [255 0 0]/255;
            else if color == "blue"
                    color = [0 0 255]/255;
            end
            end
            %Plot the volume of the robot arm by plotting the points, and
            %create the point cloud
            figure(1);

            h_ = plot3(pointCloud(:,1),pointCloud(:,2),pointCloud(:,3),'o','Color',color);
            drawnow();

            hold on;
            %max x radius
            a = (max(pointCloud(:,1)) - min(pointCloud(:,1)))/2
            %max y radius
            b = (max(pointCloud(:,2)) - min(pointCloud(:,2)))/2
            %max z radius
            c = (max(pointCloud(:,3)) - min(pointCloud(:,3)))/2
            %Assume it is a sphere, calculate it volume as a elipsoid
            volume = (4/3)*pi*a*b*c;
            %display the volume value in m^3
            disp(strcat("Approximate volume (m^3) = ",num2str(volume)));
        end

        %Plot the environment
        function PlotEnvironment()

            workspace = [-2 1.5 -1.5 1.5 -0.01 2];
            h11 = PlaceObject('BarrierThick.ply',[1.2,1.2,0]);
            hold on;
            h12 = PlaceObject('BarrierThick.ply',[-1.2,1.2,0]);
            hold on;
            h21 =PlaceObject('BarrierThick.ply',[0.5,-1,0]);
            hold on;
            h22 =PlaceObject('BarrierThick.ply',[-0.5,-1,0]);
            hold on;

            %Put fireExtingguisher, worker, table and emergencyButton
            PlaceObject('fireExtinguisher.ply',[0.85,1.4,0]);
            PlaceObject('Worker.ply',[0,2.3,0.01]);
            PlaceObject('Table.ply',[1,2.5,0]);
            PlaceObject('emergencyStopButton.ply',[1,2.3,0.55]);

            %Plot the barrier and rotate it
            h31 =PlaceObject('BarrierThick.ply',[-0.5,1.3,0]);
            verts = [get(h31,'Vertices'), ones(size(get(h31,'Vertices'),1),1)] * trotz(pi/2);
            set(h31,'Vertices',verts(:,1:3))
            hold on;

            h32 =PlaceObject('BarrierThick.ply',[0.5,1.3,0]);
            verts = [get(h32,'Vertices'), ones(size(get(h32,'Vertices'),1),1)] * trotz(pi/2);
            set(h32,'Vertices',verts(:,1:3))
            hold on;

            h41 =PlaceObject('BarrierThick.ply',[-0.5,-1.3,0]);
            verts = [get(h41,'Vertices'), ones(size(get(h41,'Vertices'),1),1)] * trotz(pi/2);
            set(h41,'Vertices',verts(:,1:3))
            hold on;

            h42 =PlaceObject('BarrierThick.ply',[0.5,-1.3,0]);
            verts = [get(h42,'Vertices'), ones(size(get(h42,'Vertices'),1),1)] * trotz(pi/2);
            set(h42,'Vertices',verts(:,1:3))
            hold on;

            %Plot the concrete ground
            set(0,'DefaultFigureWindowStyle','docked');
            surf([-2,-2;2,2] ...
                ,[-2,3;-2,3] ...
                ,[0.01,0.01;0.01,0.01] ...
                ,'CData',imread('Concrete.jpg') ...
                ,'FaceColor','texturemap');

            %Plot the surrounding wall
            surf([-2,-2;-2,-2],[-2,-2;3,3],[0.01,3;0.01,3],'CData',imread('Environment.jpg'),'FaceColor','texturemap');
            surf([-2,-2;2,2],[3,3;3,3],[0.01,3;0.01,3],'CData',imread('Environment.jpg'),'FaceColor','texturemap');
            %Plot NO SMOKING sign
            surf([-2,-2;-2,-2],[-2,-2;-1,-1],[1,2.5;1,2.5],'CData',imread('NoSmoking.png'),'FaceColor','texturemap');
            %Plot Warning sign
            s0 = surf([-2,-2;-2,-2],[-1,-1;0.5,0.5],[-1.5,-0.5;-1.5,-0.5],'CData',imread('EyeSafetyCaution.jpg'),'FaceColor','texturemap');
            rotate(s0, [-0.5 0 0], 90);
            %Plot eye safety caution sign
            s1 = surf([-0.5,-0.5;0.5,0.5],[3,3;3,3],[-1,0;-1,0],'CData',imread('Robot.jpg'),'FaceColor','texturemap');
            rotate(s1, [0 -1 0], 270);
        end

        %Plot the brick
        function [h1 h2 h3 h4 h5 h6 h7 h8 h9] = PlotBrick(brick1, brick2, brick3, ...
                brick4, brick5, brick6, ...
                brick7, brick8, brick9)
            h1 = PlaceObject('OrangeBrick.ply' ,brick1);
            h2 = PlaceObject('OrangeBrick.ply' ,brick2);
            h3 = PlaceObject('OrangeBrick.ply' ,brick3);
            h4 = PlaceObject('OrangeBrick.ply' ,brick4);
            h5 = PlaceObject('OrangeBrick.ply' ,brick5);
            h6 = PlaceObject('OrangeBrick.ply' ,brick6);
            h7 = PlaceObject('OrangeBrick.ply' ,brick7);
            h8 = PlaceObject('OrangeBrick.ply' ,brick8);
            h9 = PlaceObject('OrangeBrick.ply' ,brick9);
        end

 
    end
end